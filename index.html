<html>

<head>
    <style>
        #mycanvas {
            border: 1px solid red;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }
    </style>
</head>

<body>
    <button id="prevkey">Prev Key</button>
    <button id="nextkey">Next Key</button>
    <div id="framerate"></div>
    <canvas id="mycanvas" width="640" height="480">
    </canvas>
    <script id="model" src="model.json"></script>
    <script>
        let canvas = document.querySelector('#mycanvas');
        let gl = canvas.getContext('webgl');
        gl.getExtension('OES_element_index_uint');
        console.log(model);

        function createShaderProgram(params) {
            let vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, params.vert);
            gl.compileShader(vertShader);

            let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, params.frag);
            gl.compileShader(fragShader);

            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);

            let numUniforms = gl.getProgramParameter(shaderProgram, gl.ACTIVE_UNIFORMS);

            gl.useProgram(shaderProgram);

            let meta = {};
            for (let i = 0; i < numUniforms; ++i) {
                let info = gl.getActiveUniform(shaderProgram, i);
                meta[info.name] = {
                    location: gl.getUniformLocation(shaderProgram, info.name),
                    type: info.type,
                    size: info.size,
                };
            }

            gl.useProgram(null);

            return {
                handle: shaderProgram,
                meta: meta,
            };
        }

        function vec3Negate(v) {
            return [-v[0], -v[1], -v[2]];
        }

        function vec3Add(a, b) {
            return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
        }

        function vec3Sub(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }

        function vec3Mulf(v, s) {
            return [v[0] * s, v[1] * s, v[2] * s];
        }

        function vec3Divf(v, s) {
            return [v[0] / s, v[1] / s, v[2] / s];
        }

        function vec3Dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        };

        function vec3Cross(a, b) {
            return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        }

        function vec3Length(v) {
            return Math.sqrt(vec3Dot(v, v));
        }

        function vec3Normalize(v) {
            return vec3Divf(v, vec3Length(v));
        }

        function vec3RotateByQuat(v, q) {
        }

        function vec4Negate(v) {
            return [-v[0], -v[1], -v[2], -v[3]];
        }

        function vec4Add(a, b) {
            return [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];
        }

        function vec4Sub(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3]];
        }

        function vec4Mulf(v, s) {
            return [v[0] * s, v[1] * s, v[2] * s, v[3] * s];
        }

        function vec4Dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        }

        function mat4Identity() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1,
            ];
        }

        function mat4Multiply(a, b) {
            return [
                a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],
                a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],
                a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],
                a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],
                a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],
                a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],
                a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],
                a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],
                a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],
                a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],
                a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],
                a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],
                a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],
                a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],
                a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],
                a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]
            ];
        }

        function mat4Transpose(m) {
            return [
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15],
            ];
        }

        function mat4Translate(pos) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                pos[0], pos[1], pos[2], 1,
            ];
        }

        function mat4Scale(scale) {
            return [
                scale[0], 0, 0, 0,
                0, scale[1], 0, 0,
                0, 0, scale[2], 0,
                0, 0, 0, 1,
            ];
        }

        function mat4LookAt(eye, target, upAxis) {
            let look = vec3Normalize(vec3Sub(eye, target));
            let right = vec3Normalize(vec3Cross(upAxis, look));
            let up = vec3Normalize(vec3Cross(look, right));

            return [
                right[0], up[0], look[0], 0,
                right[1], up[1], look[1], 0,
                right[2], up[2], look[2], 0,
                -vec3Dot(right, eye), -vec3Dot(up, eye), -vec3Dot(look, eye), 1,
            ];
        }

        function mat4Perspective() {
            let fov = 60;
            let a = canvas.width / canvas.height;
            let near = 0.1;
            let far = 1000;
            let d = 1 / Math.tan(fov * 0.5 * Math.PI / 180);
            return [
                d / a, 0, 0, 0,
                0, d, 0, 0,
                0, 0, -(far + near) / (far - near), -1,
                0, 0, (-2 * far * near) / (far - near), 0
            ];
        }

        function quatGetScalarPart(q) {
            return q[3];
        }

        function quatGetImaginaryPart(q) {
            return q.slice(0, 3);
        }

        function quat(s, v) {
            return [...v, s];
        }

        function quatIdentity() {
            return quat(1, [0, 0, 0]);
        }

        function quatMultiply(a, b) {
            let s0 = quatGetScalarPart(a);
            let v0 = quatGetImaginaryPart(a);
            let s1 = quatGetScalarPart(b);
            let v1 = quatGetImaginaryPart(b);
            let s = s0 * s1 - vec3Dot(v0, v1);
            let v = vec3Add(vec3Add(vec3Mulf(v1, s0), vec3Mulf(v0, s1)), vec3Cross(v0, v1));
            return quat(s, v);
        }

        function quatConjugate(q) {
            return quat(vec3Negate(quatGetImaginaryPart(q)), quatGetScalarPart(q));
        }

        function quatRotateAroundAxis(axis, angle) {
            let halfAngle = angle * 0.5;
            return quat(Math.cos(halfAngle), vec3Mulf(vec3Normalize(axis), Math.sin(halfAngle)));
        }

        /*
        function quatRotateToVec3(from, to) {
            let axis = vec3Cross(from, to);
            let angle = Math.acos(vec3dot(from, to)) / vec3Length(to);
        }
        */

        function quatToMat4(q) {
            return [
                1 - 2 * (q[1] * q[1] + q[2] * q[2]), 2 * (q[0] * q[1] + q[3] * q[2]), 2 * (q[0] * q[2] - q[3] * q[1]), 0,
                2 * (q[0] * q[1] - q[3] * q[2]), 1 - 2 * (q[0] * q[0] + q[2] * q[2]), 2 * (q[1] * q[2] + q[3] * q[0]), 0,
                2 * (q[0] * q[2] + q[3] * q[1]), 2 * (q[1] * q[2] - q[3] * q[0]), 1 - 2 * (q[0] * q[0] + q[1] * q[1]), 0,
                0, 0, 0, 1,
            ];
        }

        function vec3Lerp(a, b, t) {
            return vec3Add(vec3Mulf(a, 1 - t), vec3Mulf(b, t));
        }

        function quatSlerp(a, b, t) {
            let d = vec4Dot(a, b);
            if (d < 0) {
                d = -d;
                a = vec4Negate(a);
            }

            let angle = Math.acos(d);

            return vec4Mulf(vec4Add(vec4Mulf(a, Math.sin((1 - t) * angle)), vec4Mulf(b, Math.sin(t * angle))), 1 / Math.sin(angle));
        }

        function setUniforms(shaderProgram, uniforms) {
            for (key in uniforms) {
                if (key in shaderProgram.meta) {
                    let value = uniforms[key];
                    let info = shaderProgram.meta[key];
                    if (info.type === gl.FLOAT_MAT4) {
                        gl.uniformMatrix4fv(info.location, false, value);
                    }
                }
            }
        };

        function setAttribute(shaderProgram, attribName, buffer, numComponents) {
            let location = gl.getAttribLocation(shaderProgram.handle, attribName);
            if (location >= 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, numComponents, gl.FLOAT, false, 0, 0);
            }
        }

        // let positions =
        //     [-0.5, -0.5,
        //         0.5, -0.5,
        //         0.5, 0.5,
        //     -0.5, 0.5];
        // let indices = [
        //     0, 1, 2, 2, 3, 0,
        // ];

        let meshes = [];

        let boneMap = new Map();

        for (let i = 0; i < model.meshes.length; ++i) {
            let meshData = model.meshes[i];
            let mesh = {
                positions: [],
                normals: [],
                boneIndices: [],
                boneWeights: [],
                numBones: [],
                indices: [],
                boneTransforms: [],
                vb: {
                    pos: null,
                    normal: null,
                    boneIndices: null,
                    boneWeights: null,
                },
                ib: null,
            };

            for (let j = 0; j < meshData.faces.length; ++j) {
                mesh.indices.push(...meshData.faces[j]);
            }
            for (let j = 0; j < meshData.vertices.length; j += 3) {
                let v = meshData.vertices;
                let n = meshData.normals;

                mesh.positions.push(v[j], v[j + 1], v[j + 2]);
                mesh.normals.push(n[j], n[j + 1], n[j + 2]);

                mesh.boneIndices.push(0, 0, 0, 0);
                mesh.boneWeights.push(1, 0, 0, 0);
                mesh.numBones.push(0);
            }

            if ('bones' in meshData) {
                for (let j = 0; j < meshData.bones.length; ++j) {
                    let bone = meshData.bones[j];
                    boneMap.set(bone.name, {
                        mesh: i,
                        bone: j,
                    });

                    mesh.boneTransforms.push(mat4Identity());

                    for (let k = 0; k < bone.weights.length; ++k) {
                        let w = bone.weights[k];
                        let vi = w[0] * 4 + mesh.numBones[w[0]];
                        ++mesh.numBones[w[0]];
                        mesh.boneIndices[vi] = j;
                        mesh.boneWeights[vi] = w[1];
                    }
                }
            }

            mesh.vb.pos = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vb.pos);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.positions), gl.STATIC_DRAW);

            mesh.vb.normal = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vb.normal);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.normals), gl.STATIC_DRAW);

            mesh.vb.boneIndices = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vb.boneIndices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.boneIndices), gl.STATIC_DRAW);

            mesh.vb.boneWeights = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vb.boneWeights);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.boneWeights), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            mesh.ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ib);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(mesh.indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            meshes.push(mesh);
        }

        console.log(meshes);

        let shaderProgram = createShaderProgram({
            vert: ` 
            precision mediump float;

            uniform mat4 uModelMat;
            uniform mat4 uViewMat;
            uniform mat4 uProjMat;
            #define MAX_NUM_BONES 16
            uniform mat4 uBones[MAX_NUM_BONES];

            attribute vec3 aPos;
            attribute vec3 aNormal;
            attribute vec4 aBoneIndices;
            attribute vec4 aBoneWeights;

            varying vec3 vNormal;

            void main() {
                mat4 boneMat =
                uBones[int(aBoneIndices.x)] * aBoneWeights.x +
                uBones[int(aBoneIndices.y)] * aBoneWeights.y +
                uBones[int(aBoneIndices.z)] * aBoneWeights.z +
                uBones[int(aBoneIndices.w)] * aBoneWeights.w;

                gl_Position = uProjMat * uViewMat * uModelMat * boneMat * vec4(aPos, 1);
                vNormal = aNormal;
            }`,
            frag: `
            precision mediump float;

            varying vec3 vNormal;

            void main() {
                gl_FragColor = vec4((vNormal + vec3(1)) * 0.5, 1);
            }`
        });

        let anim = model.animations[2];
        let channelMap = new Map();
        for (let i = 0; i < anim.channels.length; ++i) {
            channelMap.set(anim.channels[i].name, anim.channels[i]);
        }

        let currentTick = 0;

        function buildAnimBoneAux(node, parentTransform) {
            let transform = parentTransform;

            if (channelMap.has(node.name)) {
                let channel = channelMap.get(node.name);
                let v = channel.positionkeys[0][1];
                if (channel.positionkeys.length > 1) {
                    let currentKeyIndex = 0;
                    let nextKeyIndex = 0;
                    for (let i = 0; i < channel.positionkeys.length - 1; ++i) {
                        if (currentTick < channel.positionkeys[i + 1][0]) {
                            currentKeyIndex = i;
                            break;
                        }
                    }
                    nextKeyIndex = currentKeyIndex + 1;
                    let currentKey = channel.positionkeys[currentKeyIndex];
                    let nextKey = channel.positionkeys[nextKeyIndex];

                    let t = (currentTick - currentKey[0]) / (nextKey[0] - currentKey[0]);
                    console.assert(t >= 0 && t <= 1, 'what?');
                    v = vec3Lerp(currentKey[1], nextKey[1], t);
                }
                let q = [channel.rotationkeys[0][1][1],
                channel.rotationkeys[0][1][2],
                channel.rotationkeys[0][1][3],
                channel.rotationkeys[0][1][0],
                ];
                if (channel.rotationkeys.length > 1) {
                    let currentKeyIndex = 0;
                    let nextKeyIndex = 0;
                    for (let i = 0; i < channel.rotationkeys.length - 1; ++i) {
                        if (currentTick < channel.rotationkeys[i + 1][0]) {
                            currentKeyIndex = i;
                            break;
                        }
                    }
                    nextKeyIndex = currentKeyIndex + 1;
                    let currentKey = channel.rotationkeys[currentKeyIndex];
                    let nextKey = channel.rotationkeys[nextKeyIndex];
                    // console.log(currentKey, nextKey);
                    let t = (currentTick - currentKey[0]) / (nextKey[0] - currentKey[0]);
                    console.assert(t >= 0 && t <= 1, 'what?');
                    q = quatSlerp([currentKey[1][1], currentKey[1][2], currentKey[1][3], currentKey[1][0]], [nextKey[1][1], nextKey[1][2], nextKey[1][3], nextKey[1][0]], t);
                    //q = quatSlerp(currentKey[1], nextKey[1], t);
                }
                let s = channel.scalingkeys[0][1];
                if (channel.scalingkeys.length > 1) {
                    let currentKeyIndex = 0;
                    let nextKeyIndex = 0;
                    for (let i = 0; i < channel.scalingkeys.length - 1; ++i) {
                        if (currentTick < channel.scalingkeys[i + 1][0]) {
                            currentKeyIndex = i;
                            break;
                        }
                    }
                    nextKeyIndex = currentKeyIndex + 1;
                    let currentKey = channel.scalingkeys[currentKeyIndex];
                    let nextKey = channel.scalingkeys[nextKeyIndex];
                    // console.log(currentKey, nextKey);
                    let t = (currentTick - currentKey[0]) / (nextKey[0] - currentKey[0]);
                    console.assert(t >= 0 && t <= 1, 'what?');
                    s = vec3Lerp(currentKey[1], nextKey[1], t);
                }

                let localTransform = mat4Multiply(mat4Translate(v), mat4Multiply(quatToMat4(q), mat4Scale(s)));
                transform = mat4Multiply(transform, localTransform);
            } else {
                transform = mat4Multiply(transform, mat4Transpose(node.transformation));
            }
            if (boneMap.has(node.name)) {
                let boneInfo = boneMap.get(node.name);
                meshes[boneInfo.mesh].boneTransforms[boneInfo.bone] = mat4Multiply(transform, mat4Transpose(model.meshes[boneInfo.mesh].bones[boneInfo.bone].offsetmatrix));
            }
            if ('children' in node) {
                for (let i = 0; i < node.children.length; ++i) {
                    buildAnimBoneAux(node.children[i], transform);
                }
            }
        }


        let nextkeyButton = document.querySelector('#nextkey');
        nextkeyButton.addEventListener('click', () => {
            currentTick = (currentTick + 1) % anim.duration;
        });
        let prevkeybutton = document.querySelector('#prevkey');
        prevkeybutton.addEventListener('click', () => {
            currentTick = (currentTick - 1);
            if (currentTick < 0) {
                currentTick = anim.duration - 1;
            }
        });

        let oldTime = 0;
        let s = 0;

        let framerateDisplayTimer = 1;

        let draw = function (time) {
            let dt = (time - oldTime) * 0.001;
            framerateDisplayTimer += dt;
            if (framerateDisplayTimer > 1) {
                framerateDisplayTimer -= 1;
                document.querySelector('#framerate').textContent = 'Framerate: ' + (1 / dt).toFixed(2);
            }
            oldTime = time;
            // currentTick = (time * 0.001 * anim.tickspersecond) % anim.duration;
            // console.log(currentTick);

            buildAnimBoneAux(model.rootnode, mat4Identity());

            s = Math.sin(time * 0.001);

            gl.clearColor(0.9, 0.9, 0.8, 1);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
            gl.frontFace(gl.CCW);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.useProgram(shaderProgram.handle);

            let camDistance = 300;
            let camPos = [camDistance * Math.sin(time * 0.001), 100, camDistance * Math.cos(time * 0.001)];

            let uniforms = {
                uModelMat: mat4Identity(),
                uViewMat: mat4LookAt(camPos, [0, camPos[1], 0], [0, 1, 0]),
                uProjMat: mat4Perspective(),
            };

            for (let i = 0; i < meshes.length; ++i) {
                let vb = meshes[i].vb;
                let ib = meshes[i].ib;

                if (meshes[i].boneTransforms.length > 0) {
                    let matrices = [];
                    for (let j = 0; j < meshes[i].boneTransforms.length; ++j) {
                        matrices.push(...meshes[i].boneTransforms[j]);
                    }
                    uniforms['uBones[0]'] = matrices;
                } else {
                    let identityArray = [];
                    for (let j = 0; j < 16; ++j) {
                        identityArray.push(...mat4Identity());
                    }
                    uniforms['uBones[0]'] = identityArray;
                }

                setUniforms(shaderProgram, uniforms);
                setAttribute(shaderProgram, 'aPos', vb.pos, 3);
                setAttribute(shaderProgram, 'aNormal', vb.normal, 3);
                setAttribute(shaderProgram, 'aBoneIndices', vb.boneIndices, 4);
                setAttribute(shaderProgram, 'aBoneWeights', vb.boneWeights, 4);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
                gl.drawElements(gl.TRIANGLES, meshes[i].indices.length, gl.UNSIGNED_INT, 0);
            }

            window.requestAnimationFrame(draw);
        };

        draw(0);
    </script>
</body>

</html>